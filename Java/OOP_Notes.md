# OOP(Object-Oriented Programming)

> 교재: 자바의 정석 기초편 - 남궁성
> 
> 객체지향개념 학습 후 요약본을 만들기 위한 내용 정리
> 
> 6. 객체지향개념 1
> 
> 7. 객체지향개념 2


# 6-1 객체지향 언어
- 클래스의 정의: 객체를 정의해 놓은 것
- 클래스의 용도: 객체를 생성하는데 사용

# 6-2 클래스와 객체
- 클래스 = 제품 설계도 
- 객체 = 제품
- 클래스를 정의하고 클래스를 통해 객체를 생성하는 이유는 하나의 설계도만 잘 만들어 놓으면 제품을 여러 개 만드는 일이 쉬워지기 때문이다.

# 6-3 객체의 구성요소 - 속성과 기능
- 객체 = 속성(변수) + 기능(메서드)
- 객체의 멤버: 객체가 가지고 있는 속성과 기능
- 클래스란 객체를 정의한 것이므로 클래스에는 객체의 모든 속성과 기능이 정의되어 있다.

# 6-4 객체와 인스턴스
- 객체: 모든 인스턴스를 대표하는 일반적 용어
- 인스턴스: 특정 클래스로부터 생성된 객체(Tv클래스로부터 만들어진 객체 -> Tv인스턴스)
- 모든 인스턴스는 자신을 생성한 클래스의 주소를 갖고 있다.
- 클래스로부터 객체를 만드는 것을 인스턴스화라고 한다.
- 중요한 사실은 클래스(제품 설계도)를 작성했으면 따로 제품(객체)을 만들어야 사용할 수 있다는 것!
- ‘책상은 인스턴스다’라고 하기 보다는 ‘책상은 객체다’라는 쪽이, ‘책상은 책상 클래스의 객체이다’라고 하기 보다는 ‘책상은 책상 클래스의 인스턴스다’라고 하는 것이 더 자연스럽다.

## q. 클래스(설계도)가 왜 필요한가?
> a. 객체(제품)를 생성하기 위해

## q. 객체(제품)가 왜 필요한가?
> a. 객체(제품)를 사용하기 위해

## q. 객체를 사용한다는 것은?
> a. 객체가 가진 속성(변수)과 기능(메서드)을 사용하려고

# 6-5 하나의 소스파일에 여러 클래스 작성
- 하나의 소스파일에 둘 이상의 클래스를 정의하는 것도 가능.
- 주의해야할 점
  - public 클래스가 있는 경우, 소스파일의 이름은 반드시 public 클래스의 이름과 일치해야 한다.
  - public 클래스가 하나도 없는 경우, 소스파일의 이름은 파일 내의 어떤 클래스의 이름으로 해도 상관없다.
```java
	Hello2.java
	class Hello2{}
	class Hello3{}
```
  - 하나의 소스파일에 둘 이상의 public 클래스가 존재하면 안 된다. (하나의 소스파일에는 하나의 public 클래스만 허용)
- 소스파일(`*.java`)과 달리 클래스파일(`*.class`)은 클래스마다 하나씩 만들어지므로 위의 'Hello2.java'를 컴파일하면 'Hello2.class'와 'Hello3.class' 모두 두 개의 클래스파일이 생성된다. 
- 하나의 소스파일에는 하나의 클래스만 작성하는 것이 바람직

# 6-6 객체의 생성과 사용
```java
Tv t;		// Tv클래스 타입의 참조변수 t를 선언하여 생성
t = new Tv();	// Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 참조변수 t에 저장
t.channel = 7; <- 변수 사용
t.channelDown(); <- 메서드 사용 (메서드 호출)
```
- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.

# 6-7 객체의 생성과 사용 - 예제
```java
Tv t1 = new Tv(); // 객체 생성
Tv t2 = new Tv(); 
// Tv t2; t2 = new Tv();를 한 문장으로 가능 
t2 = t1;  // t1이 담고 있는 객체의 주소값을 t2에 대입된다. 즉, t1이 갖고있는 주소값과 t2의 주소값이 같아진다. 그로인해 t2가 가리키던 객체는 사용하지 않게 되어 가비지컬랙터에 의해 제거됨

t1.channel = 7; // t1이 가리키는 인스턴스의 변수 channel에 7이 대입됨
System.out.println("t1의 channel값은“ + t1.channel) // 7이 출력
System.out.println("t2의 channel값은“ + t2.channel) // t2에는 t1이 가리키는 인스턴스의 주소값이 들어있으므로 똑같이 7이 출력
```
- 두 개의 참조변수로 한 개의 객체를 가리키는 건 가능하지만 하나의 참조변수로 여러 개의 객체를 가리키는 건 불가능

# 6-8 객체 배열
- 객체 배열 == 참조변수 배열
- 많은 수의 객체를 다뤄야 할 때, 객체를 배열로 다룰 수 있는데, 이때 객체 배열 안에 객체가 저장되는 것이 아니라 객체의 주소가 저장된다.
- 즉, 객체 배열은 참조변수 배열인 것이다.
```java
Tv tv1, tv2, tv3; -> Tv[] tvArr = new Tv[3];
```
- 객체 배열을 생성하면 각 요소는 참조변수 기본값인 null로 자동 초기화
```java
Tv[] tvArr = new Tv[3]; // 참조변수 배열 생성
```
- new Tv[3]는 Tv타입의 참조변수 3개로 구성된 배열을 생성하고 그 배열의 주소값은 참조변수 tvArr에 저장됨
- 객체 배열을 생성하는 것은 참조변수들이 만들어진 것일 뿐, 아직 객체가 저장되지 않았다.
- 그래서 **꼭! 객체를 생성해서 객체 배열의 각 요소에 저장해야함!** 
- 객체 배열을 만드는 것과 객체를 만드는 것은 다름!
```java
// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
```
- 배열의 초기화 블록을 사용하여 한 줄로 처리 가능
```java
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };
```
- 객체의 수가 많으면 for문을 사용
```java
Tv[] tvArr = new Tv[3];
for(int i=0; i<tvArr.length;i++){
	tvArr[i] = new Tv();
}
```

# 6-9 클래스의 정의(1)
- 클래스: 설계도 / 데이터+함수 / 사용자정의타입
1. 변수: 하나의 데이터를 저장할 수 있는 공간
2. 배열: 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
3. 구조체: 서로 관련된 여러 데이터(종류에 관계없이)를 하나로 저장할 수 있는 공간
4. 클래스: (서로 관련 있는)데이터와 함수의 결합(구조체+함수)
- 함수는 어떤 하나의 작업을 하는 명령문들을 하나로 묶은 것이 함수
- 함수가 작업을 하려면 데이터가 필요하고, 이 두 개를 묶어놓은 것이 클래스

# 6-10 클래스의 정의(2)
- 사용자 정의 타입: 원하는 타입을 직접 만들 수 있다. (타입 == 클래스)
- 기본 자료형(8개) 외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것

# 6-11 선언위치에 따른 변수의 종류
- 변수는 선언위치에 따라서 종류가 3가지로 나뉜다.
- 클래스 안에는 클래스영역과 메서드 영역, 총 2가지 영역이 존재한다. 
- 클래스 영역: iv, cv (static + iv)
- 메서드 영역: lv
- iv는 인스턴스 변수, cv는 클래스 변수(static변수, 공유변수), lv는 지역변수
- 클래스 영역에는 선언문만 가능(변수선언, 메서드선언(메서드 정의))
## 클래스 변수 생성시기
- 클래스가 메모리에 올라갈 때(클래스가 메모리에 올라가는 시기는 클래스가 필요할 때이다.)
- 클래스는 설계도이고 이게 필요할 때는 객체를 만들 때라서 객체 만들기 전에 메모리에 올라감. 즉, 객체를 만들려면 클래스가 필요하므로 클래스파일이 하드디스크에서 RAM으로 로딩 될 때 자동으로 객체 생성없이 클래스 변수가 만들어 진다.
- 클래스는 객체를 만들 때에만 메모리에 올라갈까? -> no (벨로그 글 참고하기)
## 클래스가 메모리에 올라간다는 의미
>- 우선 컴파일된 *.class파일은 하드디스크에 저장되는데 이때 cpu는 하드디스크에서 바로 읽올 수 없다. 속도차이 때문에. 
>- 그래서 중간에 RAM이라는 메모리가 존재한다. class파일을 메모리로 올리는 것을 로딩이라고 부른다. 이를 통해 cpu는 class파일을 읽을 수 있다. 
>- cpu는 모든 작업을 RAM과 한다. 우리가 작업한 것은 다 램에 있기 때문에 그대로 컴퓨터를 끄면 다 날라간다. 그래서 작업 후 내용을 다시 디스크에 저장하는 것을 세이브라고 한다.
>- 이렇게 클래스가 메모리에 올라갈 때 클래스변수가 자동으로 생성된다. 즉, 객체 생성이 필요없다. 인스턴스 변수는 객체가 생성되어야 생성되는 것과 달리. 그래서 클래스 변수는 아무 때나 사용 가능하다.
## 인스턴스 변수 생성시기
- 인스턴스가 생성되었을 때(가장 중요!), 클래스 영역에 선언된 iv는 객체가 생성되면 만들어진다. 
- 즉, 객체는 iv의 묶음!, 그리고 iv의 묶음은 참조변수가 없어지면 가비지컬랙터에 의해 제거된다.
## 지역변수 생성시기
- 변수 선언문이 수행되었을 때(메서드가 호출되서 변수 선언문이 실행되면서 생겼다가 메서드 종료시 자동 제거)

6-12,13 클래스 변수와 인스턴스 변수
- 클래스 변수: 공통 속성(포커카드의 폭, 높이..)
- 인스턴스 변수: 개별 속성(포커카드의 무늬, 숫자..)

```java
// 객체 생성할 때
Card c = new Card(); 
// 객체 사용할 때
// 인스턴스 변수
c.kind = "HEART"; // 참조변수이름.변수이름
c.number = 5;
// 클래스 변수 (생성시 꼭!클래스이름을 써야한다)
Card.width = 200; // 클래스이름.변수이름
Card.height = 300;
```

# 6-14 메서드란?
- 문장들을 묶어놓은 것({ }이런 중괄호 블록으로 묶고 작업단위로 묶는다.)
- 어떤 값(입력)을 받아서 처리하고, 결과를 반환(출력)
- 입력받는 값이 없을 수도 있고 결과를 돌려주지 않을 수도 있다.
- 메서드의 장점
  - 코드의 중복을 줄일 수 있다.
  - 코드의 관리가 쉽다.
  - 코드를 재사용할 수 있다.
  - 코드가 간결해서 이해하기 쉬워진다.
- 메서드의 작성
  - 반복적으로 수행되는 여러 문장을 메서드로 작성
  - 하나의 메서드는 한 가지 기능만 수행하도록 작성
- 메서드 = 선언부 + 구현부

# 6-15 메서드의 선언부
- 메서드의 입력 값인 매개변수는 0 ~ n개 가능하고 출력 값은 0 ~ 1개까지만 가능! ( 출력값이 여러 개일 때는? 배열을 이용. 하나의 객체로 묶어서 출력!, 객체는 변수의 묶음이므로, 첨부파일을 한 개밖에 못 올릴 때 압축파일로 만드는 것처럼 / 반환하는 값이 없을 때는 반환타입에 void라고 써야 함!)
- 메서드의 선언부는 반환타입, 메서드 이름, 매개변수 선언으로 구성된다.

# 6-16 메서드의 구현부
- 지역변수(lv): 메서드 내에 선언된 변수
  - 메서드의 입력 값으로 받는 매개변수도 지역변수이다.
  - 지역변수는 다른 메서드의 지역변수와 이름이 겹쳐도 상관없다.

# 6-17 메서드의 호출
```java
메서드이름(값1, 값2,..); // 메서드 호출 방법
print99danAll(); // void print99danAll()이기 때문에 반환결과가 없음
int result = add(3,5); // int add(int x, int y)를 호출하고, 결과를 result에 저장, 반환타입이 int형이기 때문에 작업결과를 저장할 변수(int result)가 필요, 저장할 변수가 없이 호출해도 되지만 그러면 호출만 되고 값이 저장이 안 됨
```

- 메서드는 호출되면 메서드 영역에서 작업을 수행하고 작업을 마치면 호출한 곳으로 돌아온다.
- 메서드는 클래스 영역에만 정의할 수 있음

# 6-18,19 메서드의 실행흐름
- 클래스의 메서드를 호출하기 위해서는 클래스의 객체를 먼저 생성 후 메서드 호출

# 6-20 return문
- return문은 실행 중인 메서드를 종료하고 호출한 곳으로 되돌아간다.
- 메서드의 반환타입이 void가 아닌 경우, 반드시 return문 필요 (메서드의 반환 타입이 void일 때, return문 생략가능)

# 6-21 반환값
- 메서드는 반환타입에 맞는 값이 반환되어야 하고, 이 반환된 값을 담는 변수도 타입이 일치하거나 적어도 자동 형 변환될 수 있는 값이어야 한다.

# 6-22 호출스택
- 스택(stack): 밑이 막힌 상자. 위에 차곡차곡 쌓인다.
- 메서드 수행에 필요한 메모리가 제공되는 공간
- 메서드가 호출되면 호출스택에 수행에 필요한 메모리를 할당 받는다.
- 작업이 끝나면 호출스택에서 메서드가 사용하던 메모리 공간이 제거됨.

- 예를 들어 main메서드가 호출되서 스택에 올라가있는데 main메서드가 println메서드를 호출하면 main메서드는 대기상태가 되고 제일 위에 있던 println메서드가 실행된다.
- 아래 있는 메서드가 위의 메서드를 호출한 것
- 스택에 메서드가 여러 개 쌓일 수 있지만, 맨 위의 메서드 하나만 실행 중, 즉 하나의 스택에서는 하나의 메서드가 실행된다. 나머지 메서드는 대기중

# 6-23,24 기본형 매개변수, 참조형 매개변수
- 메서드의 매개변수는 기본형(8개)과 참조형으로 나뉜다.
- 기본형 매개변수: 변수의 값을 읽기만 할 수 있다. (read only)
- 참조형 매개변수: 변수의 값을 읽고 변경할 수 있다. (read&write)
- 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨줌
- 기본형 매개변수일 때는 기본형 값이 복사됨
- 참조형 매개변수이면 인스턴스의 주소가 복사됨
- 참조형 매개변수는 매개변수 입력값으로 객체의 주소값을 받는다.
- 즉, 기본형 매개변수는 단순히 저장된 값만 읽을 수 있지만, 참조형 매개변수는 값이 저장된 곳의 주소값을 알 수 있기 때문에 값을 읽어 오는 것 뿐 만 아니라 값을 변경하는 것도 가능함

# 6-25 참조형 반환타입
- 참조형 반환타입은 메서드가 반환하는 값의 타입이 참조형, 즉 객체의 주소값이라는 뜻이다.

# 6-26,27 static 메서드와 인스턴스 메서드
- static 메서드와 인스턴스 메서드의 차이점은 인스턴스 변수의 사용 유무이다.
- 메서드 중 static이 붙어있으면 static 메서드, 안 붙어있으면 인스턴스 메서드
- 클래스 영역에 선언된 변수를 멤버변수라 한다. 그 중에 static이 붙은 것은 클래스 변수, 붙지 않은 것은 인스턴스 변수라 한다.

## 인스턴스 메서드
  - 인스턴스 생성 후, ‘참조변수.메서드이름()’으로 호출 (객체 생성해야만 메서드 호출 가능)
  - 인스턴스 멤버(인스턴스 변수, 인스턴스 메서드)와 관련된 작업을 하는 메서드
  - 메서드 내에서 인스턴스 변수(iv) 사용 가능
- 인스턴스 변수나 메서드는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다. 인스턴스 변수가 존재한다는 것은 static변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.

## static 메서드(클래스 메서드)
 - 객체 생성없이 ‘클래스이름.메서드이름()’으로 호출
 - 인스턴스 멤버(iv,im)와 관련없는 작업을 하는 메서드
 - 메서드 내에서 인스턴스 변수 사용 불가 (static메서드는 항상 iv를 사용할 수 없게 되어 있다.)
 - 작업에 필요한 값들을 매개변수로 받아서 메서드 내에서 지역변수를 활용해 작업한다. (매개변수는 있을 수 도 있고 없을 수 도 있다.)

# 6-28 static을 언제 붙여야 할까?
- 속성(멤버 변수) 중에서 모든 인스턴스에 공통으로 사용하는 공통 속성에 static을 붙인다.
- 메서드 내에서 인스턴스 멤버(인스턴스 변수, 메서드)를 사용하지 않는다면, static을 붙이는 것을 고려한다.

# 6-29 메서드 간의 호출과 참조
- 인스턴스 메서드: 인스턴스 변수와 클래스 변수 둘 다 사용 가능(인스턴스 메서드는 객체 생성 후 사용가능하므로 객체가 생성되었다는 것은 인스턴스 변수가 존재한다는 뜻!, 클래스 변수는 언제나 사용가능)
- static 메서드: 인스턴스 변수 사용 불가, 클래스 변수만 사용 가능
  - 클래스 메서드는 인스턴스 생성 없이 호출가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 생성되었는지 존재하는지 안하는지 알 수 없다. 그래서 클래스 메서드에서는 인스턴스변수를 사용할 수 없다.
- static 메서드는 인스턴스 메서드를 호출할 수 없다.
  - 같은 클래스에 속한 멤버(변수, 메서드)들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 왜냐하면 인스턴스 메서드가 호출되었다는 것은 객체가 생성된 이후이기 때문이다. 
  - 단, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다. 클래스 멤버는 객체 생성없이 호출되므로 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 있는지 없는지 알 수 없기 때문.(객체 생성 없이는 static 메서드는 인스턴스 메서드를 호출할 수 없다.)

# 6-30,31 오버로딩
- (메서드) 오버로딩: 한 클래스 안에 같은 이름의 메서드 여러 개 정의하는 것
- 1개의 메서드 이름에 n개의 메서드를 정의
- ex) println(boolean x), println(int x), println(long x),...
- 오버로딩이 성립하기 위한 조건
  - 메서드 이름이 같아야 한다.
  - 매개변수의 개수 또는(OR) 타입이 달라야 한다.
  - 반환 타입은 오버로딩을 구현하는데 아무런 영향이 없다.(같거나 달라도 오버로딩과 상관없음)
- 메서드 오버로딩의 올바른 예는 메서드들의 이름은 1개로 통일되어 있어서 매개변수는 다르지만 같은 의미의 기능을 수행하는 것이다. 메서드 이름이 같다는 것은 하는 작업이 같다는 의미이다.
```java
int add(int a, int b), long add(long a, long b), int add(int[] a)
```


# 6-32 생성자
- 인스턴스가 생성될 때마다 호출되는 ‘인스턴스 초기화 메서드’(= iv초기화 메서드)
- 인스턴스는 객체이고 객체는 iv 묶음이라서 결국 인스턴스 초기화는 iv 초기화라고 볼 수 있다.
- 인스턴스 생성시 수행할 작업(iv 초기화)에 사용
- 이름이 클래스 이름과 같아야 한다.
- 리턴값이 없지만 void를 붙이지 않는다.
- 모든 클래스는 반드시 생성자를 가져야 한다.

# 6-33 기본 생성자
- 매개변수가 없는 생성자
- 생성자가 하나도 없을 때만, 컴파일러가 자동 추가 (그래도 웬만하면 클래스를 만들면 항상 기본 생성자를 추가하자!)
- 만약, 매개변수가 있는 생성자가 하나라도 있으면 기본 생성자가 자동으로 추가되지 않는다.
- 클래스를 만들 때 기본 생성자를 추가하는 습관을 갖자!

```java
클래스이름() {} // 기본 생성자
- Point() {}	// Point클래스의 기본 생성자
Data_2 d2 = new Data_2();
// 여기서 new뒤에 있는 ‘Data_2()’가 기본 생성자 호출 
Car c = new Car();
```
1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다.
2. 생성자 Card()가 호출되어 iv초기화 작업이 수행된다.
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.

# 6-34,35 매개변수가 있는 생성자
- 매개변수가 있는 생성자를 사용하는 이유는 한 번 작성하면 호출할 때 마다 초기화를 하지 않고 계속 쓸 수 있기 때문이다.
```java
// 생성자 만들지 않고 호출할 때
Car c = new Car();
c.color = "white";
c.gearType = "auto";
c.door = 4;
// 생성자 만들고 호출할 때
Car c = new Car("white", "auto", 4);
```
- 인스턴스를 생성할 때는 다음의 2가지 사항을 결정해야 한다.
1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

# 6-36 생성자 this()
```java
Car2() {
	this ("white", "auto", 4)
}
```
- 같은 클래스의 생성자들끼리 호출할 때 생성자의 이름으로 클래스이름 대신 this를 사용한다.
- 한 생성자의 블럭 안에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
- 생성자들끼리 호출하는 이유는 코드의 중복을 제거하기 위해서

# 6-37 참조변수 this
- 참조변수 this ≠ 생성자 this() 
  - 둘은 비슷하게 생겼을 뿐 완전 다르다
- this는 인스턴스 자신을 가리키는 참조변수
- 인스턴스 메서드(생성자 포함)에서 사용 가능
- 클래스 메서드(static 메서드)에서 사용 불가
- 주로 지역변수와 인스턴스 변수를 구별할 때 사용
- 객체 자기자신 인스턴스의 주소가 저장되어 있다.
- 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다. 즉, 따로 선언을 하지 않고 사용 가능하다.
- staic 메서드 내에서도 iv 사용 불가, this도 사용불가이다. 왜냐하면 메서드를 호출했을 때 객체가 생성되었는지 안 되었는지 알 수 없기 때문이다. 또한, this는 객체 자기 자신을 의미하기 때문이다.
```java
Car(String color, String gearType, int door) {
	this.color = color;
}
```
- 원래 iv를 호출할 때는 ‘참조변수.변수이름’ 이렇게 써야하지만 this가 안 붙은 경우는 같은 클래스내에서 iv와 lv가 구별이 된다면 생락했던 것이다. 원래는 this를 붙이는게 맞다.
```java
class MyMath2 {
      long a, b; // this.a, this.b 이게 iv의 진짜 이름 (this 생략 가능)
}
```
# 6-38 변수의 초기화
- 멤버변수와 배열은 각 타입의 기본 값으로 자동초기화 되지만, 지역변수는 필수적으로 수동초기화를 해야 한다.
- 지역변수(lv)는 수동 초기화 해야함 (사용전 꼭!!)
- 수동 초기화는 우리가 직접 초기화해야 한다는 뜻
- 멤버변수(iv, cv)는 컴파일 시 자동 초기화된다.
- 메서드는 호출스택에 메모리가 할당되는데, 호출스택은 수많은 메서드가 만들어졌다가 사라진다. 그래서 매번 지역변수를 0으로 초기화하면 성능이 떨어질 수 있어서 기존의 지역변수는 새로운 변수 값을 덮어쓰는 방법으로 처리한다.
```java
void method() {
     int i;       // 지역변수
     int j = i;  // 에러. 지역변수를 초기화하지 않고 사용
}
```
- 근데 위의 코드는 i 라는 변수가 기존의 j 변수를 덮어 써야하는데 i 변수가 무엇인지 모른다. 자동초기화가 안되기 때문에 i 변수 안에는 어떤 값이 들어있을 수 있기 때문이다. 그래서 지역변수는 항상 수동으로 직접 초기화를 해줘야 한다.
- 자동 초기화시 boolean형은 false, 참조형은 null값이고 나머지 자료형은 거의 다 0으로 초기화된다.

# 6-39,40,41 멤버변수의 초기화
- 멤버변수는 인스턴스 변수, 클래스 변수
## 1. 명시적 초기화(=)
> 변수 선언 시 대입연산자를 이용해서 초기화 하는 방법
```java
int door = 4;	// 기본형 변수의 초기화
Engine e = new Engine(); // 참조형 변수의 초기화
```
- 참조형 변수가 가질 수 있는 값은 null과 객체주소이다. 하지만 null은 변수 안에 아무것도 없는 거기 때문에 초기화라고 할 수 없다. 그래서 참조형 변수를 초기화 할려면 꼭 객체를 생성해서 주소값을 변수에 넘겨야한다.

## 2. 초기화 블럭
> 초기화작업이 복잡해지면 여러 문장을 넣어야 하는데 이때 블록 안에 여러 문장을 넣는다. 즉, 초기화 블록은 복잡한 초기화에 사용한다.
- 인스턴스 초기화 블록: { } <-  iv초기화 할 때 
- 클래스 초기화 블록: static{ }<- cv초기화 할 때

## 3. 생성자
> iv 초기화 할 때나 복잡한 초기화 할 때 사용한다.
- cv, iv의 초기화는 3가지이다.
  - 자동 초기화 0
  - 간단 초기화 =
  - 복잡 초기화 { }, static{ }, 생성자 ( { }은 iv초기화할 때 사용하지만 거의 사용하지 않는다. 그래서 복잡 초기화에서 cv는 static{}쓰고 iv는 생성자를 사용하면 됨)

## 초기화 시점
- 클래스 변수 초기화 시점: 클래스가 처음 로딩 될 때 단 한 번 (클래스가 메모리에 올라갈 때 한 번)
- 인스턴스 변수 초기화 시점: 인스턴스가 생성될 때 마다

## 초기화 순서

1. 클래스 변수(cv) 초기화 -> 인스턴스 변수(iv) 초기화 (클래스 변수가 먼저 초기화 되고 나서 인스턴스 변수가 초기화 됨)
2. 자동 -> 간단 -> 복잡(초기화 블록 -> 생성자)

|자동|간단|복잡(초기화 블록 -> 생성자)|
|:---:|:---:|:---:|
|0|=|static{}, 생성자|



# 7-1,2 상속(Inheritance)
- 기존의 클래스로 새로운 클래스를 작성하는 것.(코드의 재사용)
- 두 클래스를 부모와 자식으로 관계를 맺어주는 것.
- 자손은 조상의 모든 멤버를 상속받는다.(생성자, 초기화블럭 제외)
- 조상으로 쓴 이유는 부모의 부모도 상속받을 수 있기 때문
자손의 멤버 개수는 조상보다 적을 수 없다.(같거나 많다.)
- 조상 클래스의 멤버는 자손 클래스에 다 포함되기 때문
- 자손의 변경은 조상에 영향을 미치지 않는다. (조상 클래스의 변경은 자손에 영향을 준다.)

# 7-3 포함 관계
- 클래스의 관계는 크게 상속과 포함으로 나눌 수 있다.
- 포함이란? 클래스의 멤버로 참조변수를 선언하는 것 ( 클래스내에 객체를 만들어서 포함시키는 것)

- 그림의 두 클래스는 저장공간 수는 같지만 구조적인 차이가 있다.
```java
class Car{
	Engine e = new Engine(); // 엔진
	Door[] d = new Door[4];	  // 문, 문의 개수를 넷으로 가정하고 배열로 처리했다.
}
```
- 작은 단위의 클래스를 만들고, 이 들을 조합해서 클래스를 만든다.

# 7-4 클래스 간의 관계 결정하기
- 상속관계 '~은 ~이다. (is-a)‘
- 포함관계 '~은 ~을 가지고 있다. (has-a)‘
- 이 방법은 절대적인 건 아니고 가장 간단한 방법이라서 소개했다.
- 대부분의 경우는 포함관계이다. 상속의 경우는 드물다. 여러 가지 제약이 많기 때문
- 결정하기 어려운 경우는 드물고 잘 모르겠으면 대부분은 포함관계이다. 

# 7-5 단일상속
- java는 단일 상속만을 허용한다.(단일 상속은 하나의 부모만 상속받는 것을 말한다.)
- 다중 상속은 문제점이 발생(부모가 둘 이상이면 그 두 부모가 같은 이름의 메서드를 가질 때 충돌 문제가 발생)
- 다중 상속의 효과를 내는 방법 중 하나는 비중이 높은 클래스 하나만 상속 관계로, 나머지는 포함 관계로 한다.
```java
class TvDVD extents Tv{
	DVD dvd = new DVD(); // 포함관계
	
	void play() {  // 포함관계 객체의 메서드를 쓰기 위한 방법
		dvd.play();	
	}

	void stop() {
		dvd.stop();	
	}

}
```
# 7-6 Object 클래스
- 모든 클래스의 최고 조상
- 부모가 없는 클래스는 자동적으로 Object 클래스를 상속받게 된다.
```java
class Circle{
}
class Circle extends Object { // 컴파일러가 extends~를 추가함
}
```
- 즉, 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속받는다. toString(), equals(Object obj), hashCode()
```java
Circle c = new Circle();
System.out.println(c.toString()); 
// "Circle@15db9742"
System.out.println(c); // .toString()은 생략가능
```

- println메서드의 기능(참조변수가 들어오면 toString을 호출함)
- toString()는 참조변수가 문자열이 될 때 컴파일러가 자동으로 참조변수 뒤에 추가해준다.

# 7-7 (메서드) 오버라이딩
- 상속받은 조상의 메서드를 자신에 맞게 변경하는 것 (구현부만 변경가능, 선언부는 변경불가)
- override: 덮어쓰다

# 7-8 오버라이딩의 조건
1. 자손 클래스 메서드의 선언부가 조상 클래스의 메서드와 일치해야 한다.
(선언부: 반환타입, 메서드이름, 매개변수 목록)
2. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
3. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.(같거나 적어야 한다.)

# 7-9 오버로딩 vs 오버라이딩

- 오버로딩: (이름이 같은) 기존에 없는 새로운 메서드를 정의하는 것(new)
- 오버라이딩: 상속받은 메서드의 내용을 변경하는 것(change, modify)

# 7-10 참조변수 super
- 객체자신을 가리키는 참조변수. 인스턴스 메서드와 생성자 내에만 존재
- super는 조상멤버와 자신멤버 구별할 때 사용
- 참조변수와 this와 비슷함 (this는 lv와 iv구별할 때 사용)
  
# 7-11 super() - 조상의 생성자
- 참조변수 super와 전혀 연관 없음
- 조상의 생성자를 호출할 때 사용(자손 클래스의 생성자에서 호출하는 경우가 있음)
- 조상의 멤버는 조상의 생성자를 호출해서 초기화(자손의 생성자는 자기가 선언한 것만 초기화해야 한다.)
- 생성자의 첫줄에는 반드시 생성자(super(), this())를 호출해야 한다. (중요!)
- 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입

# 7-12 패키지
- 서로 관련된 클래스의 묶음.(모든 클래스는 패키지 안에 들어있어야 한다.)
- 클래스는 클래스 파일(*.class), 패키지는 폴더. 하위 패키지는 하위 폴더
- 클래스의 실제 이름(full name)은 패키지를 포함.(java.lang.String)

# 7-13 패키지의 선언
- 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언
- 같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다.
- 패키지 선언이 없으면 이름없는 패키지(default package)에 속하게 된다.

# 7-14 클래스 패스(classpath)
- 클래스 파일(*.class)의 위치를 알려주는 경로(path)
- 환경변수  classpath로 관리하며, 경로간의 구분자는 ';'(세미콜론)를 사용 
- classpath(환경변수)에 패키지의 루트를 등록해줘야 함.

# 7-15 import문
- 클래스를 사용할 때 패키지 이름을 생략할 수 있다.
- 컴파일러에게 클래스가 속한 패키지를 알려준다.
- import가 필요한 클래스를 사용 시 `ctrl + shift + o(알파벳)`를 누르면 자동으로 import문이 생성된다.
- java.lang패키지(핵심클래스들)의 클래스는 import하지 않고도 사용할 수 있다. (기본 패키지는 import문 생략 가능)
```java
String, Object, System, Thread...
import java.lang.*;  // *은 패키지의 모든 클래스를 의미
```
- 다른 패키지의 클래스를 쓸려면 그 클래스의 패키지를 import 해야 한다.
- import문을 선언하는 방법은 다음과 같다.
- import 패키지명.클래스명; // ctrl + shift + o 누르면 자동으로 생성됨.
또는
- import 패키지명.*;  // 패키지 내 모든클래스는 패키지 이름을 생략 가능.
- import문은 패키지문과 클래스선언의 사이에 선언한다.
- import문은 컴파일 시에 처리되므로 프로그램의 성능에 영향없음
- 첫 번째 방법이 더 명확한 정보를 제공하긴 하지만 두 방법은 사실 차이가 거의 없으므로 편한대로 사용 가능
```java
// 첫 번째 방법
import java.util.Calendar;
import java.util.Date;

// 두 번째 방법
import java.util.*; //java.util 패키지의 모든 클래스
```
- 다음의 두 코드는 서로 의미가 다르다.
```java
import java.util.*;  <- java.util 패키지의 모든 클래스
import java.*;  <- java 패키지의 모든 클래스 (java라는 이름의 패키지의 모든 클래스라는 의미라서 패키지는 포함이 안된다.)
```
- 이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여줘야 한다. ( java.util.Date <- Date라는 클래스 앞에 java.util이라는 패키지명을 붙임 )

# 7-16 static import문
- static멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.
- 그래도 클래스 이름이 있으면 명확히 알아보기 좋으니까 웬만하면 사용하지 말고 꼭 필요할 때만 사용하기
```java
import static java.lang.System.out;
import static java.lang.Math.*; // Math 클래스의 모든 static 멤버
// System.out.println(Math.random());
out.println(random());  // System이랑 Math 생략 가능
```

# 7-17 제어자(modifier)
- 클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여
- 제어자는 접근제어자와 그 외(static, final, abstract..)로 분류된다.
- 하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 4개 중 1개만)
 - 이때 순서는 상관없지만 관례적으로 접근 제어자를 맨 앞에 쓴다.

# 7-18 static - 클래스의, 공통적인
- 제어자 static의 사용대상
 - 멤버변수
  - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다. 
  - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
  - 클래스가 메모리에 로드될 때 생성된다.
 - 메서드
  - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
  - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.

# 7-19 final - 마지막의, 변경될 수 없는
- 제어자를 볼　때는 제어자를 사용할 수 있는 대상도 잘 봐야한다.
- 제어자 final의 사용대상
 - 클래스: 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다. 그래서 다른 클래스의 조상이 될 수 없다. 상속계층도의 제일 마지막이라는 의미 (대표 클래스: String, Math..)
 - 메서드: 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩(조상메서드 덮어쓰는 것)을 통해 재정의 될 수 없다.
 - 변수(멤버변수, 지역변수): 변수 앞에 final이 붙으면, 값을 변경할 수 없다.

# 7-20 abstract - 추상의, 미완성의
- 제어자 `abstract`의 사용대상
 - 클래스: 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
 - 메서드: 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.
```java
abstract class AbstractTest{  // 추상클래스(추상 메서드를 가지고 있는 클래스, 미완성 클래스)
      abstract void move();   // 추상메서드(구현부(몸통)가 없는 메서드, 미완성 메서드)
}
```
- 미완성 설계도는 제품생성 불가
```java
AbstractTest a = new AbstractTest(); 
// 에러. 추상클래스의 인스턴스 생성불가
```
- 클래스 앞에 abstract가 붙어있으면 이 클래스는 추상메서드를 갖고 있다고 생각하고 이 클래스를 사용하려면 상속을 통해서 추상메서드를 완성해야 한다는 것을 알 수 있음.
- 추상클래스를 상속받아서 완전한 클래스(완성된 설계도, 구상 클래스)를 만든 후에 객체 생성가능

# 7-21 접근 제어자
- private: 같은 클래스
- (default): 같은 패키지
- protected: 같은 패키지 + 자손 클래스 (다른 패키지)
- public: 접근 제한 없음
- 접근 범위: public > protected > (default) > private
- 클래스 앞에는 public과 (default)만 가능
- 멤버에는 4가지 다 가능

# 7-22 캡슐화와 접근 제어자
- 접근 제어자를 사용하는 이유
  - 외부로부터 데이터를 보호하기 위해서(캡슐화)
  - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서
- 제어자의 조합
  - 클래스: public, (default), final, abstract
  - 메서드: 모든 접근 제어자, final, abstract, static
  - 멤버변수: 모든 접근 제어자, final, static
  - 지역변수: final

1. 메서드에 static과 abstract를 함께 사용할 수 없다. (static메서드는 몸통이 있는 메서드에만 사용 가능)
2. 클래스에 abstract와 final을 동시에 사용할 수 없다. (서로 모순되는 의미)
3. abstract메서드의 접근제어자가 private일 수 없다. (abstract메서드는 미완성이므로 자손클래스에서 구현해줘야 함)
4. 메서드에 private과 final을 같이 사용할 필요는 없다. (둘 중 하나만 사용해도 의미가 충분함)

# 7-23 다형성
- 사전적 정의: 여러 가지 형태를 가질 수 있는 능력
- 실질적 의미: 조상타입 참조변수로 자손타입 객체를 다루는 것
- 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.
- 같은 타입의 인스턴스더라도 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.

# 7-24,25 참조변수의 형변환
- 결론: 사용할 수 있는 멤버의 갯수를 조절하는 것
- 조상과 자손 관계의 참조변수만 서로 형변환 가능(형제 관계는 형변환 불가)
- 참조변수의 형변환에서는 참조변수의 타입만 따지면 안되고 참조변수들이 가리키는 실제 인스턴스가 무엇인지 확인하고 그 인스턴스가 사용하는 멤버의 개수를 넘어서지 않으면 그 범위 내에서 늘었다가 줄었다가는 가능하다.
```java
class Car { }
class FireEngine extends Car { }
class Ambulance extends Car { }

FireEngine f = new FireEngine();
Car c = (Car)f;			// OK
FireEngine f2 = (FireEngine)c;	// OK
Ambulance a = (Ambulance)f;	// 에러(상속관계가 아닌 클래스 간의 형변환 불가)
```
- (Car)이나 (FireEngine)이 생략가능한지 안하지는 신경 쓸 필요가 없다. 왜냐하면 형변환 할 때 타입을 써주면 되기 때문이다.
- 사용할 멤버의 개수가 감소하는 것은 안전한 변환이므로 형변환 표시를 생략할 수 있다. 하지만 사용할 멤버의 개수가 증가하는 것은 안전하지 않은 변환이므로 형변환 표시를 생략할 수 없다. 새로 늘어난 멤버를 참조변수가 가리키는 객체가 쓸 수 있는지 없는지 모르기 때문에 안전하지 않다.
- 참조변수를 형변환하는 것은 리모콘을 바꾸는 것과 같다. 사용할 수 있는 멤버의 개수가 달라지기 때문이다.
- 참조변수의 형변환에서 형변환이 되냐 안되냐 혹은 형변환 표시를 생략할 수 있냐 없냐가 중요한 게 아니다. 참조변수가 가리키고 있는 실제 객체가 중요한 것이다. 그 객체가 사용할 수 있는 멤버의 개수가 예를 들어 5개면 이 5개를 넘지만 않으면 된다. 즉, 5개, 4개, 3개 이런 식으로 5개 안으로는 늘리거나 줄이는 것이 가능하지만 5개를 넘어가면 에러가 발생할 수 있다.

# 7-26 instanceof 연산자
- 참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환
- 형변환 전에 반드시 instanceof로 확인해야 함.
- c instanceof FireEngine : c가 가리키는 객체가 FireEngine이냐 또는 FireEngine의 자손이냐고 물어보는 의미이다. (c가 가리키는 객체가 FireEngine의 조상 인스턴스이면 형변환을 통해서 사용할 수 있는 멤버변수의 값(멤버의 개수)이 증가하는 것이라서 형변환 불가능하다.)
- 어떤 타입에 대한 instanceof 연산 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
FireEngine fe = new FireEngine();
System.out.println(fe instanceof Object) // true
System.out.println(fe instanceof Car)	// true
System.out.println(fe instanceof FireEngine) // true
- 위처럼 true가 나온 것은, 조상타입의 참조변수는 자손타입의 객체를 참조할 수 있기 때문에 당연한 것이다. 
Object obj = (Object) fe; // OK
Car c = (Car)fe;		 // OK

- 참조변수의 형변환은 왜 하나요?: 참조변수(리모콘)을 변경함으로써 사용할 수 있는 멤버의 개수를 조절하기 위해
- instanceof 연산자는 언제 사용하나요?: 참조변수를 형변환하기 전에 형변환 가능여부를 확인할 때

# 7-27,28 매개변수의 다형성 (다형적 매개변수)
- 다형성이란?
  1. Tv t = new SmartTv(); 
  2. 참조변수의 형번환(리모컨 바꾸기): 사용가능한 멤버 개수 조절
  3. instanceof 연산자: 형변환 가능여부 확인
- 다형성의 장점
  - 1. 다형적 매개변수
  - 2. 하나의 배열로 여러 종류 객체 다루기 (하나의 배열에 여러 종류 객체 저장 가능)

- 매개변수의 다형성
  - 참조형 매개변수는 메서드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.
  - 메서드의 매개변수로 조상타입의 참조변수를 사용해서 하나의 메서드로 여러 타입의 객체를 받을 수 있는 것
```java
void buy(Product p) { }  // 밑의 두 메서드와는 서로 다른 클래스에 존재함
b.buy(new Tv1()); //buy(Product p)와 같음
b.buy(new Computer()); //buy(Product p)와 같음
```
# 7-29,30 여러 종류의 객체를 배열로 다루기
- 조상타입의 배열에 자손들의 객체를 담을 수 있다.
- 다루고 싶은 객체들의 상속관계를 따져서 가장 가까운 공통조상 클래스 타입의 참조변수 배열을 생성해서 객체들을 저장

# 7-31 추상 클래스(abstract class)
- 미완성 설계도
- 추상클래스(미완성 클래스): 미완성 메서드(추상메서드)를 갖고있는 클래스
- 추상메서드(몸통{}이 없는 미완성 메서드)
- 추상클래스이거나 추상메서드면 abstract를 붙여야 함
- 추상 클래스로는 인스턴스 생성 불가. 그런데도 추상클래스가 있는 이유는 다른 클래스 작성에 도움을 주기 위한 것.
- 추상클래스는 상속을 통해 추상메서드를 완성해야 인스턴스 생성가능

# 7-32 추상 메서드(abstract method)
- 미완성 메서드. 구현부(몸통, {})가 없는 메서드
```java
abstract 리턴타입 메서드이름();  <- 추상 메서드
```
- 추상 메서드는 언제 사용? 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우
- 추상클래스를 상속받은 경우, 일부 추상메서드만 구현해서 사용하는 것도 가능하다. 하지만 abstract는 꼭 클래스 이름 앞에 붙여야한다.(모든 추상메서드를 다 구현한 건 아니라서 여전히 추상클래스이기 때문)
- 추상 메서드 호출 가능(호출할 때는 선언부만 필요)
-추상 클래스 안에서 인스턴스 메서드를 구현할 때 추상 메서드를 사용(호출)할 수 있다. 왜냐하면 추상클래스의 인스턴스 메서드는 객체 생성 후 사용가능하기 때문이다. 인스턴스 메서드가 호출되서 추상메서드가 사용될 수 있는 경우는 자손클래스가 상속을 통해 추상메서드를 완성해 놓았을 때 가능하다.
- 추상클래스 안에서 추상메서드 호출이 가능하다. 인스턴스 메서드를 만들고 그 안에서 추상메서드가 호출되게 하면 자손 클래스의 객체를 통해 자손 클래스에서 구현된 추상메서드가 실행된다.
- 만약에 추상 메서드에 기능을 구현하지 않고 abstract를 붙이지 않고 그냥 몸통을 비워놓은 채로 메서드를 만들어 놓으면 자손클래스가 오버라이딩을 통해 사용할 수도 있지만 강제성이 없고 자손클래스에서 조상클래스의 메서드가 구현되어있는지 없는지 알지 못 한 채로 사용할 수 있음. 꼭 필요한 기능이라는 것을 알려주면서 꼭 구현해서 사용해야한다는 것을 알려주기 위해서는 abstract를 붙여야 한다.
 
# 7-33 추상클래스의 작성 1
- 여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.